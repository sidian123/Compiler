# 正则

```
ab|c(d*|ef)*g
```

# 预处理

## 转化

```
a-b|c-(d*|e-f)*-g
```

> 其中`-`代表连接操作

## 规则

* 两个字符间有`-`

  ```
  ab  ->  a-b
  ```

* 字符与`(`间有`-`

  ```
  a(  ->  a-(
  ```

* `*`与字符间有`-`

  ```
  *a  ->  *-a
  ```

* `)`与字符间有`-`

  ```
  )a  ->  )-a
  ```

> 字符指非操作符

# 处理

## 步骤

1. 扫描源
2. 如果是操作, 入栈
3. 如果是字符, 按照规则将字符左右的操作符比对, 进行对应操作(见下)
4. 重复上述3步, 直到退出, 栈中存在唯一结果

## 规则比对表

|      | (    | )    | \|   | *      | -    | 空   |
| ---- | ---- | ---- | ---- | ------ | ---- | ---- |
| (    | 错误 | 计算 | 入栈 | 计算右 | 入栈 | 错误 |
| )    | 错误 | 错误 | 错误 | 错误   | 错误 | 错误 |
| \|   | 错误 | 计算 | 计算 | 计算右 | 入栈 | 计算 |
| *    | 错误 | 错误 | 错误 | 错误   | 错误 | 错误 |
| -    | 错误 | 计算 | 计算 | 计算右 | 计算 | 计算 |
| 空   | 入栈 | 错误 | 入栈 | 计算右 | 入栈 | 结束 |

> 列标题指字符右边的操作数, 行标题指字符左边的操作数
>
> 计算指计算左边的操作符, **入栈也意味着右边操作符优先级高**
>
> 若优先级一致时, 则计算, 即左结合

计算规则

* `(` : 简单去掉字符左右括号, 并压入栈中
* 计算右: 直接计算右侧的操作符
* 结束: 返回栈中的结果
* 其他: 简单的弹出左操作数, 与右操作数计算后, 重新压入栈中.















